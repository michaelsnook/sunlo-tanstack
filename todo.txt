EPICS
1. Got to actually build the signup workflow, for learners and friends
	1. âœ… add a mock for the form input
		1. make the form input look niceeee
	1. âœ… make the form input work
	1. ~make the signup email nice~
	1. differentiate the landing page
		1. getting-started page just has the username and primary language, creates the profile only.
			* primary: they reach with null profile
			* edge: they reach with a profile
			* primary: they create a profile
			* edge ?? they edit their profile and go back ??
		1. _then_ the differentiated page: 
			*	learners get the add-first-deck page
			* friends get an accept-friendship page
	1. landing page followup steps (/getting-started, etc.)
	1. implications: there should be someplace in /profile to change this? to "open up" the rest of the app?

ISSUES
1. When you try to sign up using existing creds you get an error and then get logged in. We
	should handle this. (inspect and special-case the error before throwing, and toast accordingly)
1. Signup workflow should not be a toast-redirect, it should be a success alert, saying go check
	and verify your email; redirect should happen after this
1. why is class s-link not working correctly in the "find a friend" search empty results section? (have manually added a border-b, like a barbarian)

JOURNEYS TO MOCK
1. Invite a friend (for a learner to invite someone by email)
		* invite email for the friend
		* accept invitation page, account signup form
		* landing page for the friend when they sign up... (what can they see?)
1. âœ… Find a friend screen (for an anon visitor to find a learner)
		* friend request dialog w signup
		* âœ… Friend request sent / pending requests
		* âœ… Friend request receive, friend request approve, friend request reject


MOCKS / Incompletes
1. The $lang/review workflow is a mock only; wire it up
		âœ… we're collecting and passing in the data
		âœ… we have an "empty" state and a "complete" state
		we have the component taking the correct data for its loop
		we have the component submitting mutations
1. Invite-A-Friend is a whole feature-set that needs to be built!
	1. âœ… Accept invite from your friend page is built; the mutation is kind of real and there are success/error states build, 
		1. We can't really test it yet, till we have actual invites
	1. âœ… Search profiles (to invite a friend)
		1. âœ… Write a mutation to send the friend request, wire up UI states
			1. This list should become aware of your current friend status with people -- change the button based on whether you've already requested the person, or are friends; (based on server state, not just for the pending mutation or error); 
				1. Then the mutation can just invalidate the page's queries
			1. Maybe don't use one mutation: use 1 per item so you can disable just that button and show that isSuccess checkmark icon instead of sharing state across all records. see example: 
		1. ISBAT see in the search results if I've already requested this person, or if we're already friends, and show that in the UI
		1. âœ… type-as-you-search, debounce it, make sure it's smooth
	1. Invite a new user (by email) is a separate screen to add (split off from the find-friend route)
1. âœ… The "Deck Home" screen or Welcome Screen
1. The "new friend signup" screens -- what are we doing here? selecting which deck(s) we're helping with... and then what?
	1. How does the friend mode sidebar look? is it the same? are some people Learners _and_ Helpers?
			(ideally, yes?) should we be switching "modes" like one context switcher that has options for
			each deck we're learning and each deck we're helping with...
	1. Public Library is a special browsing experience that needs to be built!
	1. âœ… Deck Settings: replace with the nicer radio: https://v0.dev/chat/PNg3tT-DSoC, 
			âœ… and wire up the mutation
			âœ… add the `learning_goal` field on user_deck
			âœ… add the "archive" form, and field on user_deck
			âœ… wire up the mutation
	1. Add-a-card needs form wiring

COMPONENTS (ShadCN/Radix)
1. âœ… Add a Components page to keep track of / showcase all components
1. âœ… Removing daisyUI
	1. replace dark:decoration-accent/warning
	1. disable active link (removed class `disabled`)
	1. âœ… ðŸª² find-and-fix all these: .page-card .card-white .card .alert
	1. âœ… fix color codes (text-base) in SelectOneLanguage
	1. find-replace all these colors: text-base text-base-content etc
1. use <ReloadIcon className="mr-2 h-4 w-4 animate-spin" /> for loading buttons
1. Add the "suggest edits to this card"

PRIMARY CARD INTERACTIONS
1. bring over the new structure for relations
1. make the "add to deck" function work
1. bring over the "edit status"

AUTH
1. âœ… add AuthContext -- so far I've just mocked it with useQuery
1. âœ… add signOut action to AuthContext -- correction: mocked it with its own hook
1. âœ… figure out "redirect to home screen" on logout 
1. âœ… auth guard bounce, login, redirect back (only when not logged in)
1. @TODO in the _auth/login.tsx - why using hooks? we should have this already


NAVIGATION
1. âœ… get back the "active/inactive" link style in sidebar.tsx
1. properly use the disabled option on the nav links
1. âœ… probably set it to only active-match exact route matches
1. âœ… don't forget to add the Navbar
1. âœ… add context menus (links) to all the pages and scaffold pages

UI POLISH
1. Add activity graph to deck summaries :)) https://app.radicle.xyz/nodes/seed.radicle.xyz/rad:z4V1sjrXqjvFdnCUbxPFqd5p4DtH5/tree/src/components/ActivityDiagram.svelte
1. When a loader awaits, this is a time to show blank shell and transition in

UPGRADE FORMS
1. Some existing forms don't use react-hook-form: --- the Getting Started page, the add-deck form.

DATA LOADING
1. âœ… replace useLang with router feature
1. âœ… replace the old useProfile and ProfileFull
1. âœ… refresh all the fetcher hooks w the select-paradigm code
1. don't use `enabled` to waterfall useQueries on auth context
		perhaps this will just be a code convention only render components after auth
		perhaps there is a better way to use the params / data / keys
1. Cache structure: we need to be able to retrieve objects by their UUID alone... phrases in particular.

ROUTER
1. âœ… if the navbar is not present, use its parent, somehow. (unclear why this is not happening)
1. can we aggregate all the context menu items and display them in groups. 
		(this collation should mean we can set a single page's title without affecting the menus) 
1. What is the best way to get the $lang? is it `const { lang } = Route.useParams()` ? can we not get it in page props, or context?
		- yes to context: `const data = Route.useRouteContext()` does return the queryClient and the auth object (mixed together actually)
			- further can we access context from props?
1. Standardize how we handle: `const { navigate } = useRouter()` -- can we use some props or the `Route.` methods?
1. can we access the queryClient directly from context without the hook?
1. if the validateSearch is not present, can we use its parent? or can we just get params from the parent component?
1. research loaders, preloading, query client prefetching, etc. patterns so
		we can get the most out of things. 
		* access `auth` on first render
		* suspend until profile loads
		* suspend /$lang routes until language & deck load
		* when the router loader is suspending and then stops, transition in

CROSS-PLATFORM
1. âœ… compile to android with tauri
 		Make Tauri work with HMR and Vite setup
1. compile to ios with tauri
